[
           "#include <fstream>\nusing namespace std;\n int main()\n{\n    int n;\n    ifstream f(\"halfsort3.in\");\n    f>>n;\n    int a[n+1];\n    for(int i=1;i<=n;++i)\n        f>>a[i];\n    f.close();\n    for(int i=1;i<n;++i)\n        for(int j=i+1;j<=n;++j)\n            if((a[i]%2==0&&a[j]%2==0&&a[i]>a[j])||(a[i]%2&&a[j]%2&&a[i]<a[j]))\n                swap(a[i],a[j]);\n    ofstream g(\"halfsort3.out\");\n    for(int i=1;i<=n;++i)\n        g<<a[i]<<' ';\n    g.close();\n    return 0;\n}",
           "#include <bits/stdc++.h>\nusing namespace std;\nint n,arr[251];\nlong long dp[251][251];\n int main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin>>n;\n    for(int i=0;i<n;++i)\n        cin>>arr[i];\n    for(int m=0;m<n;++m)\n    {\n        for(int i=0,j=m;j<n;++i,++j)\n        {\n            if(j<i+2)\n                dp[i][j]=0;\n            else\n            {\n                dp[i][j]=0;\n                for(int k=i+1;k<j;++k)\n                {\n                    long long val=dp[i][k]+dp[k][j]+1LL*arr[i]*arr[j]*arr[k];\n                    if(dp[i][j]<val)\n                        dp[i][j]=val;\n                }\n            }\n        }\n    }\n    cout<<dp[0][n-1];\n    return 0;\n}",
           "#include <iostream>\n#include <vector>\n#include <bitset>\n using namespace std;\n int n, A[65], B[65], c;\nvector <int> L[65];\nbitset <65> V;\nlong long X[65];\n int cupleaza(int v)\n{\n    if (V[v])\n        return 0;\n    V[v] = 1;\n    for (auto x: L[v])\n        if (!B[x])\n        {\n            A[v] = x;\n            B[x] = v;\n            return 1;\n        }\n    for (auto x: L[v])\n        if (cupleaza(B[x]))\n        {\n            A[v] = x;\n            B[x] = v;\n            return 1;\n        }\n    return 0;\n}\n int main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> X[i];\n        for (int j = 0; j < n; j++)\n            if ((X[i] >> j) & 1)\n                L[i + 1].push_back(j + 1);\n    }\n    int gata;\n    do\n    {\n        gata  = 1;\n        V.reset();\n        for (int i = 1; i <= n; i++)\n            if (!A[i])\n                if (cupleaza(i))\n                {\n                    c++;\n                    gata = 0;\n                }\n    }\n    while (!gata);\n    for (int i = 1; i <= n; i++)\n        cout << X[B[i] - 1] << \" \";\n    return 0;\n}",
           "#include <bits/stdc++.h>\n#define nmax 10005\nusing namespace std;\n int N, M, st[nmax], dr[nmax], ans;\nbool viz[nmax];\nvector <int> L[nmax];\nint n, m, a[105][105], b[105][105];\n bool Cupleaza(int k)\n{\n    if(viz[k]) return false;\n    viz[k] = true;\n    for(auto i : L[k])\n    {\n        if(!dr[i])\n        {\n            st[k] = i;\n            dr[i] = k;\n            return true;\n        }\n    }\n    for(auto i : L[k])\n        if(Cupleaza(dr[i]))\n        {\n            st[k] = i;\n            dr[i] = k;\n            return true;\n        }\n    return false;\n}\n void Read()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n        {\n            cin >> a[i][j];\n            if ((i + j) % 2 == 0) b[i][j] = ++N;\n            else b[i][j] = ++M;\n        }\n}\n void Graf()\n{\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if ((i + j) % 2 == 0 && a[i][j] == 1)\n            {\n                if (a[i-1][j] == 1) L[ b[i][j] ].push_back(b[i-1][j]);\n                if (a[i+1][j] == 1) L[ b[i][j] ].push_back(b[i+1][j]);\n                if (a[i][j+1] == 1) L[ b[i][j] ].push_back(b[i][j+1]);\n                if (a[i][j-1] == 1) L[ b[i][j] ].push_back(b[i][j-1]);\n            }\n}\n void Rezolva()\n{\n    int i, gata = 0;\n    while(!gata)\n    {\n        gata = 1;\n        for(i = 1; i <= N; i++) viz[i] = 0;\n        for(i = 1; i <= N; i++)\n            if(st[i] == 0 && Cupleaza(i))\n            {\n                ++ans;\n                gata = 0;\n            }\n    }\n    cout << ans;\n}\n int main()\n{\n    Read();\n    Graf();\n    Rezolva();\n    return 0;\n}",
           "#include <fstream>\nusing namespace std;\nint Imax[1000000],J,Jmax[1000000];\n int main()\n{\n    int c,n;\n    ifstream fin(\"oneout.in\");\n    fin>>c>>n;\n    int a[n+1]; /// Sirul de numere\n    int Max=0; /// Valoarea maxima din sir\n    for(int i=1;i<=n;++i)\n        fin>>a[i],Max=max(a[i],Max);\n    int nlp[Max+1]; /// Numere libere de patrate\n    for(int i=1;i<=Max;++i) /// Marcam ca si cum toate sunt libere de patrate\n        nlp[i]=0;\n    for(int i=2;i*i<=Max;++i) /// Marcam cu 1 cele ce nu sunt libere de patrate\n        for(int j=i*i;j<=Max;j+=i*i) /// un ciur asemanator cu Eratostene\n            nlp[j]=1;\n    ofstream fout(\"oneout.out\");\n    if(c==1)\n    {\n        int sol=0; /// Solutia\n        for(int i=1;i<=n;++i)\n            if(!nlp[a[i]]) /// Daca a[i] e liber de patrate\n                ++sol; /// incrementam solutia\n                fout<<sol<<'\\n';\n    }\n    else\n    {\n        int Secv,Smax=0,N=1,I;\n        for(int i=2;i<n;++i)\n            if(!nlp[a[i-1]]&&nlp[a[i]]&&!nlp[a[i+1]]) /// a[i-1]=liber de patrate nlp[a[i]]=1 si a[i+1]=liber de patrate\n            {\n                Secv=0;\n                I=i-1; /// Ma deplasez la stanga\n                while(!nlp[a[I]])\n                {\n                    ++Secv;\n                    if(I>1)\n                        --I;\n                    else\n                        break;\n                }\n                if(nlp[a[I]])\n                    ++I;\n                J=i+1; /// Ma deplasez la dreapta\n                while(!nlp[a[J]])\n                {\n                    ++Secv;\n                    if(J<n)\n                        ++J;\n                    else\n                        break;\n                }\n                if(nlp[a[J]])\n                    --J;\n                if(Secv>=Smax)\n                {\n                    if(Secv==Smax)\n                        ++N;\n                    else\n                        N=1,Smax=0;\n                    Smax=Secv,Imax[N]=I,Jmax[N]=J;\n                }\n            }\n        fout<<Smax<<' '<<N<<'\\n';\n        for(int i=1;i<=N;++i)\n            fout<<Imax[i]<<' '<<Jmax[i]<<'\\n';\n    }\n    return 0;\n}",
           "/// Boca Alina Gabriela - Colegiul National de Informatica Tudor Vianu Bucuresti\n #include <fstream>\n#include<cmath>\nusing namespace std;\nifstream cin(\"circular.in\");\nofstream cout(\"circular.out\");\nint a[26][26],v[26];\nlong long circular(string s)\n{\n    int cost=0,n;\n    char j='A';\n    n=s.size();\n    for(int i=0; i<n; i++)\n    {\n        if(j<s[i])\n        {\n            if(s[i]-j<'Z'-s[i]+j-64)\n                cost+=s[i]-j;\n            else\n                cost+='Z'-s[i]+j-64;\n        }\n        else\n        {\n            if(j-s[i]<'Z'-j+s[i]-64)\n                cost+=j-s[i];\n            else\n                cost+='Z'-j+s[i]-64;\n        }\n         j=s[i];\n    }\n    return cost;\n }\nint main()\n{\n    int c;\n    cin>>c;\n    string p, t,rez;\n    cin>>p>>t;\n    if(c==1)\n    {\n        cout<<circular(p);\n    }\n    else\n    {\n        int i,j,k=0,y=1;\n        string alf=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        for(i=0; i<26; i++)\n        {\n            if(alf[i]==t[k])\n            {\n                v[k]=i;\n                k++;\n            }\n            for(j=0; j<26; j++)\n                if(i<j)\n                {\n                    a[i][j]=min(abs(i-j), abs(26-j+i));\n                }\n                else\n                {\n                    a[i][j]=min(abs(i-j), abs(26-i+j));\n                }\n        }\n         int nrtotal=1,costtotal=0,q;\n        int x;\n        for(j=0; j<alf.size(); j++)\n            if(p[0]==alf[j])\n            {\n                k=j;\n                break;\n            }\n        costtotal=min(k,26-k);\n        rez.push_back(p[0]);\n        for(i=1; i<p.size(); i++)\n        {\n            for(j=0; j<alf.size(); j++)\n                if(p[i]==alf[j])\n                {\n                    q=j;\n                    break;\n                }\n            int mincost=60,nr=0;\n            for(j=0; j<t.size(); j++)\n            {\n                if (mincost>a[k][v[j]]+a[q][v[j]])\n                {\n                    mincost=a[k][v[j]]+a[q][v[j]];\n                    nr=1;\n                    x=v[j];\n                 }\n                else if(a[k][v[j]]+a[q][v[j]]==mincost)\n                {\n                    nr++;\n                    if(x>v[j])\n                    {\n                        x=v[j];\n                    }\n                }\n            }\n            rez.push_back(alf[x]);\n            nrtotal*=(nr%666013);\n            nrtotal=nrtotal%666013;\n            costtotal+=mincost;\n              rez.push_back(p[i]);\n            k=q;\n        }\n        cout<<costtotal<<endl<<nrtotal<<endl;\n        cout<<rez;\n    }\n    return 0;\n}",
           "/**\nAutor: Bogdan-Ioan Popa, FMI Universitatea din Bucuresti\nScor: 100p\n**/\n #include <bits/stdc++.h>\n #define N_MAX 60\n using namespace std;\n ifstream fin(\"patratele.in\");\nofstream fout(\"patratele.out\");\n int N, M, t;\n int A[N_MAX + 5][N_MAX + 5];\nint up[N_MAX + 5][N_MAX + 5];\nint ri[N_MAX + 5][N_MAX + 5];\nint dwn[N_MAX + 5][N_MAX + 5];\nint le[N_MAX + 5][N_MAX + 5];\nint ans[N_MAX + 5];\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, 1, 0, -1};\nint dir[] = {2, 3, 0, 1};\nint p2[] = {1, 2, 4, 8};\n char side[][8] = {\n    \"SUS\",\n    \"DREAPTA\",\n    \"JOS\",\n    \"STANGA\"\n};\n bool check_side(int conf, int side) {\n    return conf / p2[side] % 2;\n}\n void flip_side(int &conf, int side) {\n    if(check_side(conf, side)) {\n        conf -= p2[side];\n    }\n    else {\n        conf += p2[side];\n    }\n}\n int compute_ans() {\n    memset(ans, 0, sizeof(ans));\n    memset(le, 0, sizeof(le));\n    memset(ri, 0, sizeof(ri));\n    memset(up, 0, sizeof(up));\n    memset(dwn, 0, sizeof(dwn));\n     int total_ans = 0;\n     for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= M; j++) {\n            if(check_side(A[i][j], 1)) {\n                up[i][j] = 1 + up[i - 1][j];\n            }\n             if(check_side(A[i][j], 2)) {\n                le[i][j] = 1 + le[i][j - 1];\n            }\n        }\n    }\n     for(int i = N; i >= 1; i--) {\n        for(int j = M; j >= 1; j--) {\n            if(check_side(A[i][j], 0)) {\n                ri[i][j] = 1 + ri[i][j + 1];\n            }\n             if(check_side(A[i][j], 3)) {\n                dwn[i][j] = 1 + dwn[i + 1][j];\n            }\n        }\n    }\n     for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= M; j++) {\n            int max_k = min(min(dwn[i][j], ri[i][j]), min(N - i + 1, M - j + 1));\n            for(int k = 1; k <= max_k; k++) {\n                int ii = i + k - 1;\n                int jj = j + k - 1;\n                if(k <= up[ii][jj] && k <= le[ii][jj]) {\n                    ans[k]++;\n                    total_ans++;\n                }\n            }\n        }\n    }\n    return total_ans;\n}\n int main()\n{\n    fin >> N >> M >> t;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= M; j++) {\n            fin >> A[i][j];\n        }\n    }\n     int sol = compute_ans();\n    if(t == 3) {\n        int max_ans = sol;\n        int ans_i, ans_j, ans_d;\n        bool ok = false;\n        for(int i = 1; i <= N; i++) {\n            for(int j = 1; j <= M; j++) {\n                for(int d = 0; d < 4; d++) {\n                    if(!check_side(A[i][j], d)) {\n                        int ii = i + di[d];\n                        int jj = j + dj[d];\n                        flip_side(A[i][j], d);\n                        flip_side(A[ii][jj], dir[d]);\n                        int curr = compute_ans();\n                        flip_side(A[i][j], d);\n                        flip_side(A[ii][jj], dir[d]);\n                        if(max_ans < curr) {\n                            ok = true;\n                            max_ans = curr;\n                            ans_i = i;\n                            ans_j = j;\n                            ans_d = d;\n                        }\n                    }\n                }\n            }\n        }\n        if(!ok) {\n            fout << \"0\\n0 0 NU\\n\";\n        }\n        else {\n            fout << max_ans << \"\\n\" << ans_i << \" \" << ans_j << \" \" << side[ans_d] << \"\\n\";\n        }\n     }\n    else {\n        if(t == 1) {\n            fout << sol << \"\\n\";\n        }\n        else {\n            for(int i = 1; i <= N; i++) {\n                if(ans[i] != 0) {\n                    fout << i << \" \" << ans[i] << \"\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}",
           "/* autor Razvan Chivu  */\n #include <iostream>\n#include <fstream>\n using namespace std;\n int a[101][101];\n int n, m, k;\n bool inmat(int x, int y){\n    if(x >= 1 && x <= n && y >= 1 && y <= m)\n        return true;\n    return false;\n}\n void rec(int x, int y, int &s){\n    s += a[x][y];\n    a[x][y] = 0;\n     int px = x, py = y;\n     for(int i = 1; i <= k; i++){\n        px = x - i;\n        py = y;\n        if(inmat(px, py) && a[px][py])\n            rec(px, py, s);\n         px = x + i;\n        py = y;\n        if(inmat(px, py) && a[px][py])\n            rec(px, py, s);\n         px = x;\n        py = y - i;\n        if(inmat(px, py) && a[px][py])\n            rec(px, py, s);\n         px = x;\n        py = y + i;\n        if(inmat(px, py) && a[px][py])\n            rec(px, py, s);\n     }\n}\n int main()\n{\n    ifstream fin(\"ronti.in\");\n    ofstream fout(\"ronti.out\");\n     fin >> n >> m >> k;\n     for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++)\n            fin >> a[i][j];\n     int smax = 0;\n    int xmax=0, ymax=0;\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++)\n            if(a[i][j]){\n                int s = 0;\n                rec(i, j, s);\n                if(s > smax){\n                   smax = s;\n                   xmax = i;\n                   ymax = j;\n                }\n            }\n     fout << xmax << \" \" << ymax << \"\\n\" << smax;\n      return 0;\n}",
           "/**\nSursa Oficiala\nAutor : Ncu Vlad-Laurentiu\nLiceul Teoretic \"Mihail Kogalniceau\" Vaslui\n**/\n#include<fstream>\n#include<math.h>\nusing namespace std;\n ifstream  fin(\"bipatrat.in\");\nofstream fout(\"bipatrat.out\");\n long long x,y,p,q,i,j,aux;\ndouble rx,ry;\nlong long n,a[200];\nint verif(long long n)\n{\n    if(powl(floor(sqrt(n)),2)==n) return 1;\n    else return 0;\n}\n int main()\n{\n    while(fin>>x)\n    {\n        n=0;\n        if(verif(x))\n        {\n            p=1;\n            while(p<=x)p=p*10;\n            for(i=1;i<=9;i++)\n            {\n                y=i*p+x;\n                 if(verif(y))\n                {\n                    n++;\n                    a[n]=y;\n                 }\n            }\n            while(p>=10)\n            {\n                q=p/10;\n                for(i=0;i<=9;i++)\n                {\n                    y=(x/q)*p+i*q+x%q;\n                    if(verif(y))\n                    {\n                        n++;\n                        a[n]=y;\n                     }\n                }\n                p=q;\n            }\n            for(i=1;i<=n-1;i++)\n            {\n                for(j=i+1;j<=n;j++)\n                {\n                    if(a[i]>a[j])\n                    {\n                        aux=a[i];\n                        a[i]=a[j];\n                        a[j]=aux;\n                    }\n                }\n            }\n        }\n        if(n>0)\n        {\n            fout<<a[1]<<' ';\n            for(i=2;i<=n;i++)\n            {\n                if(a[i-1]<a[i])fout<<a[i]<<' ';\n            }\n            fout<<'\\n';\n        }\n        else\n        {\n            fout<<0<<'\\n';\n        }\n    }\n    fout.close();\n    fin.close();\n    return 0;\n}\n ",
           "#include <fstream>\nusing namespace std;\n static const int MAXP = 10000, MAXK = 100000, MAXCHAR = 128;\nstatic const int N = 0, E = 1, S = 2, V = 3;\n struct Rata {\n  int l, c, o;\n} virtuale[4], rate[MAXP];\n struct Query {\n  char com;\n  int nr;\n} queries[MAXK];\n // pt modulo negativ din c/c++\nint rest(const int a, const int b) {\n  int retval = a % b;\n  return retval >= 0 ? retval : retval + b;\n}\n void adv(int& x, int& y, const int o, const int nr) {\n  switch (o) {\n    case N: x -= nr; break;\n    case E: y += nr; break;\n    case S: x += nr; break;\n    case V: y -= nr; break;\n    default: break;  // unreachable\n  }\n}\n void zbr(int& l, int& c, const int nr, const int n) {\n  l = nr / n;\n  c = rest(nr, n);\n}\n int main() {\n  ifstream fin(\"pelican.in\");\n  ofstream fout(\"pelican.out\");\n  int n, p, k, x, y, o, last_z, l_aft_z, c_aft_z, total_rot;\n   fin >> n >> p >> k;\n  for (int i = 0; i < p; ++i) {\n    fin >> rate[i].l >> rate[i].c >> rate[i].o;\n    --rate[i].o;\n  }\n   // daca avem comenzi de Z nu mai conteaza pos initiala,\n  // doar unde am ajuns dupa Z\n  last_z = -1;\n  for (int i = 0; i < k; ++i) {\n    fin >> queries[i].com >> queries[i].nr;\n    if (queries[i].com == 'Z') last_z = i;\n  }\n   // inainte de Z conteaza doar comenzile R\n  total_rot = 0;\n  if (last_z >= 0) {\n    zbr(l_aft_z, c_aft_z, queries[last_z].nr, n);\n    for (int i = 0; i < last_z; ++i)\n      if (queries[i].com == 'R')\n        total_rot += queries[i].nr;\n  }\n   // simulez comenzi cu rata \"virtuala\" din (0, 0) cu orientarea N\n  x = y = o = 0;\n  for (int i = last_z + 1; i < k; ++i) {\n    if (queries[i].com == 'R') o = (o + queries[i].nr) % 4;\n    else if (queries[i].com == 'A') adv(x, y, o, queries[i].nr);\n  }\n   x %= n; y %= n;\n   for (int i = 0; i < p; ++i) {\n    if (last_z >= 0) {\n      rate[i].l = l_aft_z;\n      rate[i].c = c_aft_z;\n      rate[i].o = (rate[i].o + total_rot) % 4;\n    }\n     // aflu poz finala in functie de cea a ratei virtuale\n    switch (rate[i].o) {\n      case N:\n        fout << rest(rate[i].l + x, n) << ' ' << rest(rate[i].c + y, n) << '\\n'; break;\n      case E:\n        fout << rest(rate[i].l + y, n) << ' ' << rest(rate[i].c - x, n) << '\\n'; break;\n      case S:\n        fout << rest(rate[i].l - x, n) << ' ' << rest(rate[i].c - y, n) << '\\n'; break;\n      case V:\n        fout << rest(rate[i].l - y, n) << ' ' << rest(rate[i].c + x, n) << '\\n'; break;\n      default: break;  // unreachable\n    }\n  }\n   return 0;\n}",
           "#include <fstream>\n#include <vector>\n#include <queue>\n std::ifstream fin(\"apa.in\");\nstd::ofstream fout(\"apa.out\");\n typedef std::vector<std::vector<int>> mat;\n int n, m, flow;\nmat V, C;\nstd::vector<int> root;\n inline void read()\n{\n    int i, j, c;\n     fin >> n;\n     V.resize(1LL * n + 1);\n    root.resize(1LL * n + 1);\n    C.resize(1LL * n + 1);\n     for (int i = 1; i <= n; ++i)\n        C[i].resize(1LL * n + 1);\n     while (fin >> i >> j >> c)\n    {\n        V[i].push_back(j);\n        V[j].push_back(i);\n        C[i][j] = c;\n    }\n}\n inline bool bfs(int k)\n{\n    std::queue<int> Q;\n     Q.push(k);\n    fill(root.begin(), root.end(), 0);\n     while (!Q.empty())\n    {\n        k = Q.front(), Q.pop();\n         for (auto const& i : V[k])\n            if (!root[i] && C[k][i] > 0)\n            {\n                root[i] = k;\n                Q.push(i);\n                 if (i == n)\n                    return true;\n            }\n    }\n     return false;\n}\n inline void search(int const& start)\n{\n    int cmin, i;\n     while (bfs(start))\n    {\n        cmin = 2e9, i = n;\n         while (i != start)\n        {\n            if (C[root[i]][i] < cmin)\n                cmin = C[root[i]][i];\n            i = root[i];\n        }\n         flow += cmin;\n         i = n;\n         while (i != start)\n        {\n            C[root[i]][i] -= cmin;\n            C[i][root[i]] += cmin;\n            i = root[i];\n        }\n    }\n}\n inline void display()\n{\n    if (flow) fout << flow << '\\n';\n    else fout << \"Apa nu ajunge!\";\n}\n int main()\n{\n    read();\n    search(1);\n    display();\n    return 0;\n}"
]